;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; (C)  ANS  (Armourer)		 ┼┼┼┴┴┴┼┼┴┼┼┴┼┼┴┴┴┼┼	  Universal Modifier ;;
;; FIDOnet 2:461/29.444		 ┼┼ ├┤ ├┤ ┴┼ ├┤ ┴┬┼┼		Version 1.00 ;;
;; ──────────────────		 ┼┤ ┌┐ ├┤ ┼┬ ├┼┴┬ ┼┼		    07.06.95 ;;
;; Kharkov, Ukraine		 ┼┼┬┼┼┬┼┼┬┼┼┬┼┼┬┬┬┼┼	FreeWare, SourceWare ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Универсальный модификатор
;
; Формат запуска:
; <имя входного файла> <имя выходного файла> <имя модуля> <параметры модуля>
;
; Последние два байта модуля .mdf - адрес startup-процедуры
;
; Startup-процедуре в DI передается длина модифицируемого файла,
; который лежит по адресу ES:0, в SS:BP - адрес командной строки после <fname>
; (ведущие пробелы в передаваемой ком. строке уже убраны)
;
; Startup-процедура должна вернуть в DI количество байт в файле
; после обработки, в CX - длину основной процедуры, приписываемой к началу
; результирующего файла, в DX - адрес основной процедуры (в сегменте кода
; startup-процедуры)
;
segment	cseg	para
	assume	cs:cseg
	org	100h
start	proc	near

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Отсюда идет основной код
;
; Последовательность действий:
; 1. Открываем и читаем входной файл в CS+1030:0
; 2. Создаем выходной файл
; 3. Открываем и читаем модуль-модификатор в CS+30:0
; 4. Передаем управление startup-процедуре mdf-модуля
; 5. Пишем в выходной файл основной код модификации, затем обработанные данные
;    из входного файла. Закрываем выходной файл
;
; Действия 1-3 выполняются в процессе разбора командной строки
;
;;;;;;;;; Разбор командной строки ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Готовим регистры и флаги для разбора параметров командной строки
	cld
	mov	bx, 80h
	mov	si, bx
	mov	bl, byte ptr [si]	; Сейчас в BX - длина ком. строки

	; Ставим признак конца командной строки - dw 0
	inc	si			; Теперь [BX+SI] указывают на 0Dh,
	xor	ax, ax			; а SI - на первый символ ком.строки
	mov	word ptr [bx + si], ax

;;;;;;;;; 1. Открываем и читаем входной файл
	; Читаем этот файл в буфер CS+1030h
	mov	cx, 1030h
	call	readfile

	; Сохраняем сегмент и длину прочитанного файла
	push	ds		; Сегмент сохраняем пока в ES -
	pop	es		; в свяхи с грядущей перенастройкой стека ;)
	mov	bp, di		; Длину сохраняем в BP

;;;;;;;;; 2. Создаем выходной файл
	; Нормализуем DS
	push	cs
	pop	ds

	; Получаем имя файла
	call	getfname

	; Создаем файл с обычными атрибутами
	mov	ah, 3ch
	xor	cx, cx
	int	21h
	jnc	@@created

	; Ошибка создания файла
	mov	cx, offset f_wr_err
	jmp	abend

;;;;;;;;; 3. Открываем и читаем модуль-модификатор
@@created:

	push	ax		; Сохраняем дескриптор выходного файла

	; Дальше идет имя .mdf-модуля
	; Читаем этот файл в буфер CS+30h
	mov	cx, 30h
	call	readfile

	; Настраиваем стек
	pop	ax
	mov	sp, offset newstack
	push	ax

	; Создаем адрес перехода на startup-процедуру для call dword ptr...
	mov	word ptr [di], ds		; CS для дальнего перехода

	; Устанавливаем параметры для входа в startup-процедуру
	xchg	si, di		; Адрес перехода в SI, адрес ком.строки - в DI
	xchg	bp, di		; Адрес ком. строки в BP, длина модифициру-
				; емого файла - в DI

	call	dword ptr [si - 2]	; Запуск startup-процедуры

	; Сейчас в DI имеем длину файла после модификации
	; в DX - адрес основного кода навески,
	; в CX - длину навески

	; Пишем основной код mdf-модуля
	pop	bx		; Восстанавливаем дескриптор нового файла
	mov	ah, 40h
	int	21h
	; Здесь на ошибку не проверяем - если она будет сейчас, то будет
	; и при второй попытке записи


	mov	cx, di	; Восстанавливаем длину обработанного входного файла
	push	es	; Устанавливаем сегмент буфера входного файла
	pop	ds
	xor	dx, dx	; Данные в буфере располагаются со смещения 0

	; Пишем данные из модифицированного файла
	mov	ah, 40h
	int	21h
	jnc	@@close

	; Сообщаем об ошибке
	push	cs
	pop	ds
	mov	dx, offset f_wr_err
	mov	ah, 9
	int	21h
	int	20h

@@close:
	; Закрываем файл
	mov	ah, 3eh
	int	21h

	; Выход в DOS
	int	20h
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Закончили основной код ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Процедура чтения имени файла из командной строки (с удалением ведущих
; пробелов) и считывания файла с этим именем в память
;
; Командная строка должна обрываться dw 0
;
; Параметры:
;	SI - текущий символ командной строки
;	CX - смещение (от CS в параграфах) сегмента буфера для чтения файла
;
; Результат:
;	SI - второй байт за именем файла в командной строке
;	DI - число реально считанных байт (длина файла)
;	DS - установлен на семент буфера (т.е. CS+CX на входе)
;
readfile	proc	near
	; Нормализуем DS
	push	cs
	pop	ds

	; Получаем имя файла
	call	getfname

	; Открываем файл
	mov	ax, 3d00h
	int	21h
	jnc	@@opened

	; Ошибка - не можем открыть файл
	mov	cx, offset f_rd_err

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Вывод имени файла, сообщения об ошибке и выход в DOS
	;
	; Параметры:
	;	CX - адрес сообщения об ошибке
	;	DX - имя файла
	;	SI - адрес первого байта за последним символом имени файла
	;
abend:
	; Для корректного сообщения нужно установить признак конца имени файла
	mov	byte ptr [si], '$'	; Затираем первый символ за концом
	mov	ah, 9			; имени файла - но он нам уже
	int	21h			; не пригодится ;(
	mov	dx, cx
	int	21h
	int	20h


@@opened:
	mov	bx, ax			; Сохраняем дескриптор открытого файла

	; Пропускаем пробелы после имени файла
	; Это нужно для последнего readfile - чтобы в startup-процедуру
	; вернуть адрес командной строки уже без ведущих пробелов
	call	skipspc

	; Читаем файл
	mov	ax, cs			; Вычисляем сегмент буфера
	add	ax, cx
	mov	ds, ax			; Сегмент буфера
	xor	dx, dx			; Смещение в буфере
	mov	cx, -1
	mov	ah, 3fh			; Читаем файл
	int	21h

	; Сохраняем число реально прочитанных байт
	mov	di, ax

	; Закрываем файл
	mov	ah, 3eh
	int	21h

	; Возвращаемся
	retn
readfile	endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Получение имени файла из командной строки
;
; Признаком конца строки считается '\0'
; Отсутствие имени файла считается ошибкой
;
; Параметры:
;	DS:SI - ком.строка
;
; Результат:
;	DX - адрес имени файла (с завершающим '\0')
;	SI - первый символ за именем файла (т.е. - за символом '\0')
;
getfname	proc	near
	; Удаляем ведущие пробелы
	call	skipspc

	; Если дошли до конца строки => файл не указан => ошибка - нужен хелп
	jnz	@@further

	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; Вывод текста подсказки и выход в DOS
	;
help		proc	near
	mov	al, 10
	int	29h
	mov	al, '╒'
	int	29h
	mov	cx, 78
	mov	al, '═'
	int	29h
	loop	$-2
	mov	ah, 9
	mov	dx, offset maintitle
	int	21h
	int	20h
help		endp

@@further:
	; Запоминаем указатель на имя файла
	mov	dx, si

	; Пропускаем имя файла в ком. строке
@@search_spc:
	lodsb
	cmp	al, '!'
	jnc	@@search_spc

	; Ставим признак конца имени файла
	mov	byte ptr [si-1], dh	; dh всегда 0 (ком.строка лежит в PSP)

	; Возвращаемся
	retn
getfname	endp
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Пропуск ведущих пробелов (пробел - все, что меньше '!')
; Признаком конца строки считается '\0'
;
; Параметры:
;	DS:SI - ком.строка
;
; Результат:
;	ZF - установлен, если в процессе поиска достигнут конец строки
;	SI - указатель на первый не-пробел
;	AL - первый символ не-пробел
;	
skipspc		proc	near
	lodsb			; Читаем очередной символ
	dec	al		; 0 становится 255
	cmp	al, ' '		; '!' соответственно тоже становится ' '
	jc	skipspc		; Пропускаем все, что меньше '!'
	dec	si		; Устанавлваем SI на первый не-пробел
	inc	al		; Корректируем al и устанавливаем ZF как надо
	retn			; Возвращаемся
skipspc		endp


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Глобальные данные - строки заставки и файловых ошибок
;
	; Сообщения о файловых ошибках
f_rd_err:	db	' - can',39,'t be opened',13,10,'$'
f_wr_err:	db	'Can',39,'t write the output file',13,10,'$'

	; Основной текст подсказки
maintitle:
db 13,10
db '│ (C)  ANS  (Armourer)		 Universal Modifier		 V 1.00',13,10
db '│ FIDOnet 2:461/29.444		FreeWare, SourceWare		28.05.95',13,10
db '│',13,10
db '│',13,10
db '│	Usage:	MDF  <input>  <output>  <module>  [par',39,'s]',13,10
db '│',13,10
db '│',13,10
db '│',13,10
db '│				 Read the  MDF.DOC  for more information',13,10
db '│',13,10
db '│',13,10
db '│','$'

	; Сообщения о файловых ошибках
f_cr_err:	db	'Can',39,'t create the file $'

	; Сюда переопределяется SP перед чтением модуля .mdf
align	2
newstack	label	byte

start	endp
cseg	ends
end	start
