;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; (C) Armourer (2:461/29.444 aka 2:461/35.444)
; Простейшая шифровка файла по xor
; (Модуль xorer.mdf для universal modifier 1.00)
;
; Необходимое условие для корректной работы этой защиты:
; последние два байта защищаемого файла должны содержать адрес точки входа
; (он может отличаться от 100h, что сводит с ума автораспаковщики)
; Если файл не отвечает этому требованию, Вы легко можете привести его
; в соттветствие им с помощью hex-mode во внутреннем редакторе
; Volkov Commander'а ;)
;
cseg	segment	para
	assume	cs:cseg
	locals

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Основной код защиты
;
; Будет приписан к концу исполняемого файла
; В начало исполняемого файла будет положен CALL main
;
main	proc	near
	; Берем адрес первого закодированного байта
	pop	di

	; Берем целевой адрес для раскодированных байт
	xchg	si, di		; В SI при старте .com-программ лежит 100h

	; Раскодируем файл
len	=	$ + 1		; Адрес слова с длиной кодированного файла
	mov	cx, 0

	mov	al, 73h		; Значение шифрования

@@decode_loop:
	xor	byte ptr [si], al
	movsb
	loop	@@decode_loop

	; Стартуем
	jmp	[di - 2]

main	endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Эта процедура шифрует по xor то, что ей дают, затем к концу шифрованных
; данных дописывает расшифровщик.
; "Официальный" же расшифровщик представляет собой CALL на процедуру main,
; дописанную к концу файла
;
; Последние два байта шифруемого файла должны содержать адрес точки входа
;
; При старте по адресу ES:0 лежат данные, подлежащие шифровке,
; а DI содержащит длину этих данных
;
; Возвращает в DI длину кодированных данных, в CX - 3,
; в DX - адрес CALL main
; 
startup	proc	near
	; Смещение стартовой точки мы возьмем из файла

	; Сохраняяем адрес последнего байта за хвостом данных
	push	di

	; И его же пишем в адрес начального CALL
	mov	word ptr ds:[start+1], di	; Префикс нужен для глупого
						; Tasm'а, который иначе ставит
						; префикс cs:

	; Сохраняем длину шифруемых данных для main
	; (в процессе шифровки длина данных не меняется)
	mov	word ptr ds:[len], di

	; Дописываем процедуру раскодирования к хвосту данных
	xor	si, si
	mov	cx, offset startup
	cld
	rep	movsb

	; Восстанавливаем адрес последнего байта за хвостом файла
	pop	si

	; Шифруем данные
	mov	al, 73h		; Код шифрования

@@encode_loop:
	xor	byte ptr es:[si-1], al	; SI указывает на байт, следующий
	dec	si			; за тем, который нужно распаковать
	jne	@@encode_loop	; Кроме того, такая индексация дает нам
				; возможность сделать простой цикл до SI == 0,
				; гарантируя при этом, что байт по адресу 0
				; тоже будет зашифрован.

	; Сейчас в DI имеем новую длину файла (без учета стартового call)
	; Устанавливаем CX и DX
	mov	cx, 3			; длина стартового CALL
	mov	dx, offset start	; Адрес стартового CALL

	; Возвращаемся в protect
	retf
startup	endp

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Этот CALL кладется в начало зашифрованного файла, а адрес перехода
; корректируется так, чтобы указывать на расшифровщик, приписанный к концу
; файла
;
start:	
	db	0e8h		; CALL near ptr на следующую команду
	dw	0

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Здесь лежит адрес startup-процедуры для universal modifier
;
dw	offset startup

cseg	ends
end	main
